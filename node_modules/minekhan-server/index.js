const { cos, sin, round, floor, ceil, min, max, abs, sqrt, atan, atan2 } = Math;

//db
const level = require('level')
const leveldb = level('db')

if (!leveldb.supports.permanence) {
  throw new Error('Persistent storage is required')
}

var db = {
  get:async function(key){
    var value = await leveldb.get(key).catch(() => null)
    if(value){
      return JSON.parse(value)
    }else{
      return null
    }
  },
  set:async function(key, value, options){
    if(!(options && options.raw)) value = JSON.stringify(value)
    await leveldb.put(key, value)
    return this
  },
  delete:async function(key){
    await leveldb.del(key)
    return this
  },
  list:function(prefix, values){
    return new Promise(function(resolve, reject){
      var obj = values ? {} : []
      leveldb.createReadStream()
      .on('data', function (data) {
        if(prefix && !data.key.startsWith(prefix)){
          return
        }
        if(values){
          obj[data.key] = JSON.parse(data.value)
        }else{
          obj.push(data.key)
        }
      })
      .on('error', function (err) {
        console.log('Oh my!', err)
        reject(err)
      })
      .on('close', function () {
        //console.log('Stream closed')
      })
      .on('end', function () {
        resolve(obj)
      })
    })
  }
}

//log
let log = []
async function Log(){
  var data = []
  for(var i=0; i<arguments.length; i++){
    data.push(arguments[i])
  }
  console.log(...data)
  //var log = await db.get("log")
  //log = log || []
  log.push(data)
  await db.set("log", log)
}

function clearLog(){
  db.delete("log").then(() => {
    console.clear()
    log = []
  })
}
console.clear()
db.get("log").then(r => {
  r.forEach(v => {
    console.log(...v)
  })
  log = r
}).catch(() => {})

let version = "Alpha 1.0.5"
function verMoreThan(a,b){
  a = a.split(".")
  b = b.split(".")
  if(a[0] > b[0]) return true
  if(a[1] > b[1] && a[0] === b[0]) return true
  if(a[2] > b[2] && a[1] === b[1]) return true
}
let generator = {
  height: 80, // Height of the hills
  smooth: 0.01, // Smoothness of the terrain
  extra: 30, // Extra height added to the world.
  caveSize: 0.00, // Redefined right above where it's used
  biomeSmooth: 0.007, // Smoothness of biomes
}
const {
  seedHash,
  hash
} = (() => {
  // closure around mutable `seed`; updated via calls to `seedHash`

  let seed = Math.random() * 2100000000 | 0;

  const PRIME32_2 = 1883677709;
  const PRIME32_3 = 2034071983;
  const PRIME32_4 = 668265263;
  const PRIME32_5 = 374761393;

  const seedHash = s => {
    seed = s | 0;
  }

  const { imul } = Math;

  const hash = (x, y) => {
    let h32 = 0;

    h32 = seed + PRIME32_5 | 0;
    h32 += 8;

    h32 += imul(x, PRIME32_3);
    h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
    h32 += imul(y, PRIME32_3);
    h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

    h32 ^= h32 >> 15;
    h32 *= PRIME32_2;
    h32 ^= h32 >> 13;
    h32 *= PRIME32_3;
    h32 ^= h32 >> 16;

    return h32 / 2147483647;
  };

  return {
    seedHash,
    hash
  };
})();
class Marsaglia {
  // from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c

  nextInt() {
    const { z, w } = this;

    this.z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;
    this.w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;

    return ((this.z & 0xFFFF) << 16 | this.w & 0xFFFF) & 0xFFFFFFFF;
  }

  nextDouble() {
    const i = this.nextInt() / 4294967296;

    const is_less_than_zero = (i < 0) | 0; // cast to 1 or 0

    return is_less_than_zero + i;
  }

  constructor(i1, i2) { // better param names
    this.z = (i1 | 0) || 362436069;
    this.w = i2 || hash(521288629, this.z) * 2147483647 | 0;
  }
}
class PerlinNoise {
  // http://www.noisemachine.com/talk1/17b.html
  // http://mrl.nyu.edu/~perlin/noise/

  static grad3d(i, x, y, z) {
    const h = i & 15; // convert into 12 gradient directions

    const u = h < 8
    ? x
    : y;

    const v = h < 4
    ? y
    : h === 12 || h === 14
    ? x
    : z;

    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
  }

  static grad2d(i, x, y) {
    const v = (i & 1) === 0
    ? x
    : y;

    return (i & 2) === 0
      ? -v
    : v;
  }

  static grad1d(i, x) {
    return (i & 1) === 0
      ? -x
    : x;
  }

  static lerp(t, a, b) {
    return a + t * (b - a);
  }

  // end of statics

  // permutation
  perm = new Uint8Array(0x200);

// prototype functions:
noise3d(x, y, z) {
  const { floor } = Math;

  const X = floor(x) & 0xff;
  const Y = floor(y) & 0xff;
  const Z = floor(z) & 0xff;

  x -= floor(x);
  y -= floor(y);
  z -= floor(z);

  const fx = (3 - 2 * x) * x * x;
  const fy = (3 - 2 * y) * y * y;
  const fz = (3 - 2 * z) * z * z;

  const { perm } = this;

  const p0 = perm[X] + Y;
  const p00 = perm[p0] + Z;
  const p01 = perm[p0 + 1] + Z;
  const p1 = perm[X + 1] + Y;
  const p10 = perm[p1] + Z;
  const p11 = perm[p1 + 1] + Z;

  const { lerp, grad3d } = PerlinNoise;

  return lerp(
    fz,
    lerp(
      fy,
      lerp(
        fx,
        grad3d(perm[p00], x, y, z),
        grad3d(perm[p10], x - 1, y, z)
      ),
      lerp(
        fx,
        grad3d(perm[p01], x, y - 1, z),
        grad3d(perm[p11],x - 1, y - 1, z)
      )
    ),
    lerp(
      fy,
      lerp(
        fx,
        grad3d(perm[p00 + 1], x, y, z - 1),
        grad3d(perm[p10 + 1], x - 1, y, z - 1)
      ),
      lerp(
        fx,
        grad3d(perm[p01 + 1], x, y - 1, z - 1),
        grad3d(perm[p11 + 1], x - 1, y - 1, z - 1)
      )
    )
  );
}

noise2d(x, y) {
  const { floor } = Math;

  const X = floor(x) & 0xff;
  const Y = floor(y) & 0xff;

  x -= floor(x);
  y -= floor(y);

  const { perm } = this;
  const fx = (3 - 2 * x) * x * x;
  const fy = (3 - 2 * y) * y * y;
  const p0 = perm[X] + Y;
  const p1 = perm[X + 1] + Y;

  const { lerp, grad2d } = PerlinNoise;

  return lerp(
    fy,
    lerp(
      fx,
      grad2d(
        perm[p0],
        x,
        y
      ),
      grad2d(
        perm[p1],
        x - 1,
        y
      )
    ),
    lerp(
      fx,
      grad2d(
        perm[p0 + 1],
        x,
        y - 1
      ),
      grad2d(
        perm[p1 + 1],
        x - 1,
        y - 1
      )
    )
  );
}

noise1d(x) {
  const { floor } = Math;

  const X = floor(x) & 0xff;

  x -= floor(x);

  const fx = (3 - 2 * x) * x * x;

  const { lerp, grad1d } = PerlinNoise;

  return lerp(
    fx,
    grad1d(perm[X], x),
    grad1d(perm[X + 1], x - 1)
  );
}

constructor(seed) {
  if (seed === undefined) {
    throw new TypeError("A value for `seed` parameter was not provided to `PerlinNoise`");
  }

  const rnd = new Marsaglia(seed);

  // generate permutation
  const { perm } = this;

  // fill 0x0..0x100
  for (let i = 0; i < 0x100; ++i) {
    perm[i] = i;
  }

  for (let i = 0; i < 0x100; ++i) {
    const j = rnd.nextInt() & 0xFF;
    const t = perm[j];
    perm[j] = perm[i];
    perm[i] = t;
  }

  // copy to avoid taking mod in perm[0]
  // copies from first half of array, into the second half
  perm.copyWithin(0x100, 0x0, 0x100);
}
}
let blockIds = {
  grass:1,
  dirt:2,
  stone:3,
  bedrock:4,
  sand:5,
  gravel:6,
  Water:145,
  snowBlock:325,
  snow:326,
  sandstone:264,
  podzol:466,
}
let CUBE,SLAB,STAIR,CROSS,TALLCROSS,DOOR,TORCH,LANTERN,LANTERNHANG,BEACON,
    CACTUS,PANE,PORTAL,WALLFLAT,TRAPDOOR,TRAPDOOROPEN,FENCE,WALLPOST,WALL,
    WALLU,//wall withe exteion under another wall
    FENCQ,//fence (one extension)
    BUTTON,CHAIN,POT,POTCROSS,CARPET,LAYER1,LAYER2,LAYER3,LAYER4,LAYER5,LAYER6,LAYER7,LAYER8,
    FLIP,NORTH,SOUTH,EAST,WEST,ROTATION// Mask for the direction bits
CUBE = 0
LAYER2 = SLAB = 0x100<<5 // 9th bit
LAYER3 = STAIR = 0x200<<5 // 10th bit
LAYER4 = CROSS = 0x300<<5
LAYER5 = TALLCROSS = 0x700<<5
LAYER6 = LANTERN = 0x900<<5
LAYER7 = LANTERNHANG=0x1100<<5
BEACON = 0x1300<<5
CACTUS = 0x1400<<5
POT = 0x1500<<5
POTCROSS = 0x1700<<5
LAYER1 = TORCH = 0x1800<<5
CHAIN = 0x1900<<5
LAYER8 = DOOR = 0x2100<<5
PORTAL = 0x2200<<5
WALLFLAT = 0x2300<<5
PANE = 0x4400<<5
TRAPDOOR = 0x2800<<5
TRAPDOOROPEN=0x4000<<5
FENCE = 0x6000<<5
WALLPOST = 0x6200<<5
WALL = 0x6400<<5
WALLU = 0x6600<<5 //wall withe exteion under another wall
FENCQ = 0x4100<<5 //fence (one extension)
BUTTON = 0x4200<<5
CARPET    = 0x4300<<5
FLIP      = 0x400 // 11th bit
NORTH = 0 // 12th and 13th bits for the 4 directions
SOUTH = 0x800
EAST = 0x1000
WEST = 0x1800
ROTATION = 0x1800 // Mask for the direction bits

function getBiome(biome){
  if(biome > 0.6){
    return "snowyField"
  }else if(biome > 0.5){
    return "desert"
  }else if(biome > 0.4){
    return "field"
  }else if(biome > 0.37){
    return "jungle"
  }else if(biome > 0.35){
    return "giantJungle"
  }else if(biome > 0.3){
    return "bambooForest"
  }else{
    return "oakForest"
  }
}

class Section{
  constructor(x, y, z, size, chunk) {
    this.x = x
    this.y = y
    this.z = z
    this.size = size
    this.arraySize = size * size * size
    this.blocks = new Int32Array(this.arraySize)
    this.tags = new Array(this.arraySize) //tags are like nbt in minecraft
    this.chunk = chunk
    this.world = (chunk && chunk.world) || world
    this.edited = false
    this.pallete = [0]
    this.palleteMap = {"0": 0}
    this.palleteSize = 0
  }
  getBlock(x, y, z) {
    let s = this.size
    return this.blocks[x * s * s + y * s + z]
  }
  setBlock(x, y, z, blockId) {
    let s = this.size
    this.blocks[x * s * s + y * s + z] = blockId
  }
  deleteBlock(x, y, z) {
    let s = this.size
    this.blocks[x * s * s + y * s + z] = 0
  }
  getTags(x, y, z){
    let s = this.size
    return this.tags[x * s * s + y * s + z]
  }
  setTags(x,y,z, data){
    let s = this.size
    this.tags[x * s * s + y * s + z] = data
  }
}
class Chunk{
  constructor(x, z, world) {
    this.x = x
    this.z = z
    this.sections = []
    this.cleanSections = []
    this.tops = new Uint8Array(16 * 16) // Store the heighest block at every (x,z) coordinate
    this.biomes = new Array(16 * 16) // biome type at every (x,z) coordinate
    this.edited = false
    this.loaded = false
    this.generate = false
    this.world = world
  }
  getBlock(x, y, z) {
    let s = y >> 4
    return s < this.sections.length && s >= 0 ? this.sections[s].getBlock(x, y & 15, z) : 0
  }
  setBlock(x, y, z, blockID, user) {
    if(y<0) return
    if (!this.sections[y >> 4]) {
      do {
        this.sections.push(new Section(this.x, this.sections.length * 16, this.z, 16, this))
      } while (!this.sections[y >> 4])
    }
    if (user && !this.sections[y >> 4].edited) {
      this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
      this.sections[y >> 4].edited = true
      this.edited = true
    }
    this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
  }
  deleteBlock(x, y, z, user) {
    if (!this.sections[y >> 4]) {
      return
    }
    if (user && !this.sections[y >> 4].edited) {
      this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
      this.sections[y >> 4].edited = true
      this.edited = true
    }
    this.sections[y >> 4].deleteBlock(x, y & 15, z)
  }
  getTags(x, y, z){
    let s = y >> 4
    return this.sections.length > s ? this.sections[s].getTags(x, y & 15, z) : null
  }
  setTags(x,y,z,data){
    let s = y >> 4
    if(this.sections.length > s) this.sections[s].setTags(x, y & 15, z, data)
  }
  load() {
    var world = this.world
    let chunkX = this.x >> 4
    let chunkZ = this.z >> 4
    let load = null
    let loadFrom = world.loadFrom
    
    for (let i = 0; i < loadFrom.length; i++) {
      load = loadFrom[i]
      if (load.x === chunkX && load.z === chunkZ) {
        let y = load.y * 16
        for (let j in load.blocks) {
            world.setBlock((j >> 8 & 15) + this.x, (j >> 4 & 15) + y, (j & 15) + this.z, load.blocks[j])
        }
        loadFrom.splice(i--, 1)
      }
    }
    this.loaded = true
  }
}
class World{
  constructor(){
    this.chunks = []
    this.editedTags = []
    this.version = version
    this.seed = 0
    this.superflat = true
    this.caves = false
    this.trees = true
    this.survival = true
    this.p = {
      x:8,
      y:6,
      z:8,
      rx:0,
      ry:0,
      spectator:false,
      flying:false
    }
    this.noiseProfile = {
      generator: undefined,
      octaves: 4,
      fallout: 0.5,
      seed: undefined,
      noiseSeed(seed) {
        this.seed = seed;
        this.generator = new PerlinNoise(this.seed);
      },
      noise(x, y, z) {
        const { generator, octaves, fallout } = this;

        let effect = 1,
            k = 1,
            sum = 0;

        for (let i = 0; i < octaves; ++i) {
          effect *= fallout;

          const k = 1 << i;

          let temp;
          switch (arguments.length) {
            case 1: {
              temp = generator.noise1d(k * x);
              break;
            } case 2: {
              temp = generator.noise2d(k * x, k * y);
              break;
            } case 3: {
              temp = generator.noise3d(k * x, k * y, k * z);
              break;
            }
          }

          sum += effect * (1 + temp) / 2;
        }

        return sum;
      }
    };
    this.save = false
  }
  setSeed(seed){
    let noiseProfile = this.noiseProfile
    this.seed = seed
		seedHash(this.seed)
		noiseProfile.noiseSeed(this.seed)
    this.p.y = this.superflat ? 6 : (round(noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra)
  }
  getChunk(x,z){
    return this.chunks[x] && this.chunks[x][z]
  }
  setBlock(x,y,z,blockID){
    let chunkX = x >> 4
    let chunkZ = z >> 4
    if(!this.chunks[chunkX]){
      this.chunks[chunkX] = []
    }
    let chunk = this.chunks[chunkX][chunkZ]
    if(!chunk){
      chunk = new Chunk(chunkX*16,chunkZ*16,this)
      this.chunks[chunkX][chunkZ] = chunk
      this.genChunk(chunk)
    }
    chunk.setBlock(x & 15, y, z & 15, blockID, this)
    this.save = true
  }
  getBlock(x,y,z){
    let chunkX = x >> 4
    let chunkZ = z >> 4
    let xm = x & 15
    let zm = z & 15
    let chunk = this.getChunk(chunkX,chunkZ)
    return chunk && chunk.getBlock(xm,y,zm)
  }
  tagsChanged(x,y,z, t){
    var str = x.toString(36)+","+y.toString(36)+","+z.toString(36)
    var editedTags = this.editedTags
    if(t){
      if(!editedTags.includes(str)) editedTags.push(str)
    }else{
      if(editedTags.includes(str)){
        editedTags.splice(editedTags.indexOf(str),1)
      }
    }
    this.save = true
  }
  setTags(x,y,z,data){
    let chunkX = x >> 4
    let chunkZ = z >> 4
    let xm = x & 15
    let zm = z & 15
    let chunk = this.getChunk(chunkX,chunkZ)
    if(chunk){
      chunk.setTags(xm,y,zm,data)
      this.tagsChanged(x,y,z,data)
    }
  }
  getTags(x,y,z){
    let chunkX = x >> 4
    let chunkZ = z >> 4
    let xm = x & 15
    let zm = z & 15
    let chunk = this.getChunk(chunkX,chunkZ)
    return chunk && chunk.getTags(xm,y,zm)
  }
  genChunk(chunk){
    let x = chunk.x >> 4
    let z = chunk.z >> 4
    let trueX = chunk.x
    let trueZ = chunk.z

    if (chunk.generated) {
      return false
    }
    let noiseProfile = this.noiseProfile
    let superflat = this.superflat
    let smoothness = generator.smooth
    let hilliness = generator.height
    let biomeSmooth = generator.biomeSmooth
    let gen = 0, floatGen = 0
    for (let i = 0; i < 16; i++) {
      for (let k = 0; k < 16; k++) {
        let wx = trueX + i, wz = trueZ + k
        floatGen = noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness + generator.extra
        gen = superflat === "island" && chunk.type === "" ? 0 : (superflat ? 4 : Math.round(floatGen))
        chunk.tops[k * 16 + i] = gen
        if(chunk.type === "nether"){
        }else if(chunk.type === "end"){
        }else if (superflat === "island") {
        } else if(superflat === "void"){
          chunk.biomes[k * 16 + i] = "field"
        } else if(superflat){
          chunk.tops[k * 16 + i] = gen;
          chunk.biomes[k * 16 + i] = "field"

          chunk.setBlock(i, gen, k, blockIds.grass);
          chunk.setBlock(i, gen - 1, k, blockIds.dirt);
          chunk.setBlock(i, gen - 2, k, blockIds.dirt);
          chunk.setBlock(i, gen - 3, k, blockIds.dirt);
        }else{
          let biome = noiseProfile.noise((trueX + i) * biomeSmooth, (trueZ + k) * biomeSmooth);
          var b = getBiome(biome)
          chunk.biomes[k * 16 + i] = b
          if(b === "desert"){
            chunk.tops[k * 16 + i] = gen;

            chunk.setBlock(i, gen, k, blockIds.sand);
            chunk.setBlock(i, gen - 1, k, blockIds.sand);
            chunk.setBlock(i, gen - 2, k, blockIds.sandstone);
            chunk.setBlock(i, gen - 3, k, blockIds.sandstone);
            if(gen<60) {
              gen = 59;
              chunk.setBlock(i, gen+1, k, blockIds.Water | SLAB);
              chunk.setBlock(i, gen, k, blockIds.Water);
              chunk.setBlock(i, gen - 1, k, blockIds.Water);
              chunk.setBlock(i, gen - 2, k, blockIds.gravel);
              chunk.setBlock(i, gen - 3, k, blockIds.gravel);
            }
            if(gen>120){
              chunk.setBlock(i, gen, k, blockIds.stone);
            }
            if(gen>140){
              chunk.setBlock(i, gen, k, blockIds.sand);
            }
          }

          if(b === "field" || b === "oakForest"){
            chunk.tops[k * 16 + i] = gen;

            chunk.setBlock(i, gen, k, blockIds.grass);
            chunk.setBlock(i, gen - 1, k, blockIds.dirt);
            chunk.setBlock(i, gen - 2, k, blockIds.dirt);
            chunk.setBlock(i, gen - 3, k, blockIds.dirt);
            if(gen<60) {
              gen = 59;
              chunk.setBlock(i, gen+1, k, blockIds.Water | SLAB);
              chunk.setBlock(i, gen, k, blockIds.Water);
              chunk.setBlock(i, gen - 1, k, blockIds.Water);
              chunk.setBlock(i, gen - 2, k, blockIds.gravel);
              chunk.setBlock(i, gen - 3, k, blockIds.gravel);
            }
          }
          if(b === "snowyField"){
            chunk.tops[k * 16 + i] = gen;

            if(gen >= 60){
              var h = ceil(((floatGen + 0.5) % 1) * 8)
              switch(h){//really smooth terrain!
                case 1:
                  chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER1)
                  break
                case 2:
                  chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER2)
                  break
                case 3:
                  chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER3)
                  break
                case 4:
                  chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER4)
                  break
                case 5:
                  chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER5)
                  break
                case 6:
                  chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER6)
                  break
                case 7:
                  chunk.setBlock(i, gen + 1, k, blockIds.snow | LAYER7)
                  break
                case 8:
                  chunk.setBlock(i, gen + 1, k, blockIds.snowBlock)
                  break
              }
              chunk.setBlock(i, gen, k, blockIds.grass | CROSS);
              chunk.setBlock(i, gen - 1, k, blockIds.dirt);
              chunk.setBlock(i, gen - 2, k, blockIds.dirt);
              chunk.setBlock(i, gen - 3, k, blockIds.dirt);
            }
            if(gen<60) {
              gen = 59;
              chunk.setBlock(i, gen+1, k, blockIds.ice);
              chunk.setBlock(i, gen, k, blockIds.ice);
              chunk.setBlock(i, gen - 1, k, blockIds.Water);
              chunk.setBlock(i, gen - 2, k, blockIds.gravel);
              chunk.setBlock(i, gen - 3, k, blockIds.gravel);
            }
          }

          if(b === "jungle" || b === "giantJungle" || b === "bambooForest"){
            chunk.tops[k * 16 + i] = gen;

            if(b === "bambooForest") chunk.setBlock(i, gen, k, blockIds.podzol)
            else chunk.setBlock(i, gen, k, blockIds.grass)
            chunk.setBlock(i, gen - 1, k, blockIds.dirt);
            chunk.setBlock(i, gen - 2, k, blockIds.dirt);
            chunk.setBlock(i, gen - 3, k, blockIds.dirt);

            if(gen<60) {
              chunk.setBlock(i, 60, k, blockIds.Water | SLAB);
              for(var y=59; y>=gen; y--){
                chunk.setBlock(i, y, k, blockIds.Water);
              }
              chunk.setBlock(i, gen, k, blockIds.gravel);
              chunk.setBlock(i, gen - 1, k, blockIds.gravel);
            }
          }
        }
        for (let j = 1; j < gen - 3; j++) {
          chunk.setBlock(i, j, k, blockIds.stone)
        }
        chunk.setBlock(i, 0, k, blockIds.bedrock)
      }
    }
    chunk.generated = true
  }
  getTop(x,z){
    let chunkX = x >> 4
    let chunkZ = z >> 4
    let xm = x & 15
    let zm = z & 15
    let chunk = this.getChunk(chunkX,chunkZ)
    return chunk && chunk.tops[zm*16+xm]
  }
  getSaveString(){
    let world = this
    let chunks = this.chunks
    let p = this.p
    let superflat = this.superflat
    
    let edited = [], pallete = {}
    for (let x in chunks) {
      for (let z in chunks[x]) {
        let chunk = chunks[x][z]
        if (chunk.edited) {
          for (let y = 0; y < chunk.sections.length; y++) {
            if (chunk.sections[y].edited) {
              edited.push([ chunk.sections[y], chunk.cleanSections[y] ])
            }
          }
        }
      }
    }
    for (let chunks of edited) {
      let changes = false
      chunks[0].blocks.forEach((id, i) => {
        if (id !== chunks[1][i]) {
          pallete[id] = true
          changes = true
        }
      })
      if (!changes) {
        chunks[0].edited = false
      }
    }

    let blocks = Object.keys(pallete).map(n => Number(n))
    pallete = {}
    blocks.forEach((block, index) => pallete[block] = index)
    blocks = blocks.map(b => b.toString(36)).join(",")
    
    let rnd = Math.round
    let options = p.flying | (superflat==="island" ? 2 : (superflat === "void" ? 3 : superflat)) << 1 | p.spectator << 3 | this.caves << 4 | this.trees << 5 | this.survival << 6

    let str = "" + ";" + world.seed.toString(36) + ";"
      + rnd(p.x).toString(36) + "," + rnd(p.y).toString(36) + "," + rnd(p.z).toString(36) + ","
      + (p.rx * 100 | 0).toString(36) + "," + (p.ry * 100 | 0).toString(36) + "," + options.toString(36) + ";"
      + (verMoreThan(this.version, "1.0.2") ? version : this.version) + ";"
      + blocks+";"

    for (let i = 0; i < edited.length; i++) {
      if (!edited[i][0].edited) {
        continue
      }
      let real = edited[i][0]
      let blocks = real.blocks
      let original = edited[i][1]
      str += (real.x / 16).toString(36) + "," + (real.y / 16).toString(36) + "," + (real.z / 16).toString(36) + ","
      for (let j = 0; j < original.length; j++) {
        if (blocks[j] !== original[j]) {
          str += (pallete[blocks[j]] << 12 | j).toString(36) + ","
        }
      }
      str = str.substr(0, str.length - 1); //Remove trailing comma
      str += ";"
    }
    if (str.match(/;$/)) str = str.substr(0, str.length - 1)
    
    return str
  }
  getEditedTags(){
    var obj = {}
    for(var pos of this.editedTags){
      var arr = pos.split(",")
      obj[pos+","] = this.getTags(parseInt(arr[0], 36),parseInt(arr[1], 36),parseInt(arr[2],36))
    }
    return obj
  }
  loadSave(str) {
    let data = str.split(";")
    if (!str.includes("Alpha")) {
      return this.loadOldSave(str)
    }
    let p = this.p

    this.name = data.shift()
    this.setSeed(parseInt(data.shift(), 36))

    let playerData = data.shift().split(",")
    p.x = parseInt(playerData[0], 36)
    p.y = parseInt(playerData[1], 36)
    p.z = parseInt(playerData[2], 36)
    p.rx = parseInt(playerData[3], 36) / 100
    p.ry = parseInt(playerData[4], 36) / 100
    let options = parseInt(playerData[5], 36)
    let v = data[0].replace("Alpha ","")
    let extra = verMoreThan(v, "1.0.3") || v === "1.0.3"
    p.flying = options & 1
    this.superflat = options >> 1 & 3
    p.spectator = options >> (2+extra) & 1
    if(this.superflat === 0) this.superflat = false
    if(this.superflat === 1) this.superflat = true
    if(this.superflat === 2) this.superflat = "island"
    if(this.superflat === 3) this.superflat = "void"
    this.caves = options >> (3+extra) & 1
    this.trees = options >> (4+extra) & 1
    this.survival = (options >> (5+extra) & 1) ? true : false

    let version = data.shift()
    this.version = version

    let pallete = data.shift().split(",").map(n => parseInt(n, 36))
    this.loadFrom = []

    for (let i = 0; data.length; i++) {
      let blocks = data.shift().split(",")
      if(blocks[0].startsWith("|")){
        break
      }
      
      var loadFrom = this.loadFrom
      loadFrom.push({
        x: parseInt(blocks.shift(), 36),
        y: parseInt(blocks.shift(), 36),
        z: parseInt(blocks.shift(), 36),
        blocks: [],
      })
      for (let j = 0; j < blocks.length; j++) {
        let block = parseInt(blocks[j], 36)
        let index = block & 0xffffff
        let pid = block >> 12
        loadFrom[loadFrom.length-1].blocks[index] = pallete[pid]
      }
    }

    while(loadFrom.length){
      var c = loadFrom[0]
      var chunk = new Chunk(c.x*16,c.z*16,this)
      if(!this.chunks[c.x]) this.chunks[c.x] = []
      this.chunks[c.x][c.z] = chunk
      this.genChunk(chunk)
      chunk.load()
    }
  }
  loadEditedTags(obj){
    for(var t in obj){
      var data = obj[t]
      var pos = t.split(",")
      this.setTags(parseInt(pos[0],36),parseInt(pos[1],36),parseInt(pos[2],36),data)
    }
  }
}

const WebSocketServer = require('websocket').server;
let didInit = false
function init(serverPort, name,description, options){
  if(didInit) throw new Error("Cannot initialize more than 1 time.")
  didInit = true
  var onJoin
  var saveActivity = options.saveActivity !== undefined ? options.saveActivity : true
  var thumbnail = options.thumbnail || null
  var admins = Array.isArray(options.admins) ? options.admins : []
  var playersInv = {}
  db.get("playersInv").then(r => {
    if(r) playersInv = r
  })
  
  var defaultSettings = {
    tntExplode:true,
    killCmdOff:false,
    dayNightCycle: false,
    blocksFall: true,
    pvp: true,
    fireSpreads: true
  }
  var rooms = {}
  function createRoom(name, options){
    if(rooms[name]) throw "Room called "+name+" has already been created."
    options.autosave = options.autosave !== undefined ? options.autosave : options.canEdit
    var world = new World()
    if(options.autosave){
      db.get("save:"+name).then(r => {
        if(r){
          world.loadSave(r.code)
          world.loadEditedTags(r.tags)
        }else{
          if(options.code) world.loadSave(options.code)
        }
      })
    }else if(options.code) world.loadSave(options.code)
    return rooms[name] = {
      name:name,
      code: options.code,
      world: world,
      spawn: options.spawn, //array
      canEdit: options.canEdit !== undefined ? options.canEdit : !options.code,
      autosave: options.autosave,
      players: [],
      entities: [],
      textEntities:[],
      replacableTextEntities:[],
      addText:function(x,y,z,text,color = null, background = null, size = 1/32,){
        var ent = {id:Date.now(),entType:"TextEntity",dimension:"",originalText:text,pos:{x,y,z,text,size,color,background}}
        this.textEntities.push(ent)
        if(text.match(/{username}/)){
          this.replacableTextEntities.push(ent)
        }
        var room = this
        return {
          ent,
          setText:function(text){
            this.ent.pos.text = text
            this.ent.originalText = text
            if(text.match(/{username}/) && !room.replacableTextEntities.includes(this.ent)){
              room.replacableTextEntities.push(this.ent)
            }
          }
        }
      },
      hasEntity:function(id){
        for(var ent of this.entities){
          if(ent.id === id) return true
        }
      },
      portals: [],
      addPortal: function(where, x,y,z, x2,y2,z2){
        var temp
        if(x > x2) temp = x, x = x2, x2 = temp
        if(y > y2) temp = y, y = y2, y2 = temp
        if(z > z2) temp = z, z = z2, z2 = temp
        
        if(typeof where === "function"){
          this.portals.push({
            func:where,
            x,y,z,x2,y2,z2
          })
        }else{
          this.portals.push({
            to:where,
            x,y,z,x2,y2,z2
          })
        }
      },
      inPortal: function(x,y,z){
        for(var p of this.portals){
          if(
            x >= p.x &&
            x <= p.x2 &&
            y >= p.y &&
            y <= p.y2 &&
            z >= p.z &&
            z <= p.z2
            ) return p.func || p.to
        }
        return false
      },
      setBlock:function(x,y,z,block){
        var b = this.world.getBlock(x,y,z)
        this.world.setBlock(x,y,z,block)
        var o = {type:"setBlock", data:{x:x, y:y, z:z, block:block, dimension:"", prevBlock:b}}
        for(var p of this.players){
          p.sendJSON(o)
        }
      },
      settings: Object.assign({}, defaultSettings, options.settings),
      time: 375,
      uneditable:[],
      addUneditable:function(x,y,z,x2,y2,z2){
        var temp
        if(x > x2) temp = x, x = x2, x2 = temp
        if(y > y2) temp = y, y = y2, y2 = temp
        if(z > z2) temp = z, z = z2, z2 = temp
        
        this.uneditable.push({x,y,z,x2,y2,z2})
      },
      inUneditable:function(x,y,z){
        for(var p of this.uneditable){
          if(
            x >= p.x &&
            x <= p.x2 &&
            y >= p.y &&
            y <= p.y2 &&
            z >= p.z &&
            z <= p.z2
            ) return true
        }
        return false
      }
    }
  }
  function deleteRoom(name){
    delete rooms[name]
  }

  function updateEntities(){
    for(var i in rooms){
      var room = rooms[i]
      for(var text of room.textEntities){
        if(!room.hasEntity(text.id)){
          room.entities.push(text)
        }
      }
    }
    for(var p of players){
      if(!(p.room && p.room.entities.length)) continue
      for(var ent of p.room.replacableTextEntities){
        ent.pos.text = ent.originalText.replace("{username}",p.username)
      }
      p.sendJSON('{"type":"entityPosAll","data":'+JSON.stringify(p.room.entities)+"}")
    }
  }
  
  var goToRoomQueue = []
  function updateGoToRoomQueue(){
    if(!goToRoomQueue.length) return
    for(var i = goToRoomQueue.length - 1; i >= 0; i--){
      var idx = goToRoomQueue[i].indexOf(":")
      var p = findPlayerById(goToRoomQueue[i].slice(0,idx))
      if(!p) continue
      p.goToRoom(goToRoomQueue[i].slice(idx+1))
      goToRoomQueue.splice(i,1)
    }
  }
  var playerFunctionQueue = []
  function updatePlayerFunctionQueue(){
    if(!playerFunctionQueue.length) return
    for(var i = playerFunctionQueue.length - 1; i >= 0; i-=2){
      if(players.includes(playerFunctionQueue[i-1])){
        playerFunctionQueue[i](playerFunctionQueue[i-1])
      }
      playerFunctionQueue.splice(i-1,2)
    }
  }
  function save(){
    for(var i in rooms){
      var room = rooms[i]
      if(!room.autosave || !room.world.save) continue
      let w = room.world
      w.save = false
      db.set("save:"+room.name, {
        code:w.getSaveString(),
        tags:w.getEditedTags()
      })
    }
    db.set("playersInv",playersInv)
  }
  function updateSettings(){
    for(var i in rooms){
      var room = rooms[i]
      if(room.settings.dayNightCycle){
        var s = 0, total = 0
        for(var p of room.players){
          if(p.pos && p.pos.sleeping) s++
          total++
        }
        if(s === total) room.time += 125
        else room.time += 2.5
      }
    }
    for(var p of players){
      if(!p.room) continue
      p.sendJSON({type:"settings", time:p.room.time, data:p.room.settings})
    }
  }
  
  setInterval(function(){
    updateEntities()
    updateGoToRoomQueue()
    updatePlayerFunctionQueue()
    updateSettings()
    save()
  }, 1000)
  
  var players = []
  function sendAllPlayers(msg){
    for(var i=0; i<players.length; i++){
      var p = players[i]
      p.sendJSON(msg)
    }
  }
  function sendPlayer(msg, to){
    for(var i=0; i<players.length; i++){
      var p = players[i]
      if(p.id === to){
        p.sendJSON(msg)
      }
    }
  }
  function sendPlayerName(msg, to){
    for(var i=0; i<players.length; i++){
      var p = players[i]
      if(p.username === to){
        p.sendJSON(msg)
      }
    }
  }
  function closePlayer(id){
    for(var i=0; i<players.length; i++){
      var p = players[i]
      if(p.username === id){
        p.close()
      }
    }
  }
  function findPlayer(id){
    for(var i=0; i<players.length; i++){
      var p = players[i]
      if(p.username === id){
        return p
      }
    }
  }
  function findPlayerById(id){
    for(var i=0; i<players.length; i++){
      var p = players[i]
      if(p.id === id){
        return p
      }
    }
  }
  
  const wsServer = new WebSocketServer({
    httpServer: serverPort
  })
  wsServer.on("request", req => {
    const connection = req.accept(null, req.origin);
    players.push(connection)
    
    connection.sendJSON = function(data, con = connection){
      if(typeof data === "object") data = JSON.stringify(data)
      con.sendUTF(data)
    }
    
    function sendPlayers(msg){
      for(var i=0; i<players.length; i++){
        var p = players[i]
        if(p !== connection){
          p.sendJSON(msg)
        }
      }
    }
    function sendThisPlayer(msg){
      connection.sendJSON(msg)
    }
    function sendPlayersThisRoom(msg){
      for(var i=0; i<players.length; i++){
        var p = players[i]
        if(p !== connection && connection.room === p.room){
          p.sendJSON(msg)
        }
      }
    }
    function closeThisPlayer(){
      connection.close()
    }
    function closePlayers(){
      for(var i=0; i<players.length; i++){
        var p = players[i]
        if(p !== connection){
          p.close()
        }
      }
    }
    
    connection.on('message', function(message) {
      var data
      try{
        data = JSON.parse(message.utf8Data)
      }catch{
        return
      }
      if(data.type === "connect"){
        if(saveActivity) Log(data.username+" has joined");else console.log(data.username+" has joined")
        connection.username = data.username
        connection.id = data.id
        connection.room = null
        connection.goToRoom = function(room){
          if(!rooms[room]) throw "No such room called "+room
          if(this.room){
            this.room.players.splice(this.room.players.indexOf(this), 1)
          }
          this.room = room = rooms[room]
          if(!playersInv[connection.username]){
            playersInv[connection.username] = {}
          }
          var inv = playersInv[connection.username]
          inv.survival = room.world.survival
          if(room.spawn){
            inv.x = room.spawn[0]
            inv.y = room.spawn[1]
            inv.z = room.spawn[2]
          }
          sendThisPlayer({
            type:"loadSave",
            data:room.canEdit ? room.world.getSaveString() : room.code,
            tags:room.canEdit ? room.world.getEditedTags() : null,
            cheats:false,
            time:375,
            inv: inv
          })
          this.room.players.push(this)
          for(var p of players){
            if(p !== connection && p.room !== room){
              if(p.hiddenPos) sendThisPlayer(p.hiddenPos)
              if(connection.hiddenPos) p.sendJSON(connection.hiddenPos)
            }
          }
        }
        if(onJoin) onJoin(connection)
        sendPlayers(JSON.stringify({
          type:"message",
          data: data.username+" is connecting. "+players.length+" players now.",
          username: "Server",
          fromServer:true
        }))
      }else if(data.type === "joined"){
        sendPlayers(JSON.stringify({
          type:"message",
          data: data.username+" joined. ",
          username: "Server",
          fromServer:true
        }))
      }else if(data.type === "pos"){
        connection.pos = data.data
        for(var i=0; i<players.length; i++){
          var p = players[i]
          if(p !== connection){
            if(p.room === connection.room) p.sendJSON(message.utf8Data)
          }
        }
        if(data.inv) playersInv[connection.username] = data.inv
        sendThisPlayer(JSON.stringify({
          type:"canSendPos"
        }))

        var temp = data.data.hidden
        data.data.hidden = true
        connection.hiddenPos = JSON.stringify(data)
        data.data.hidden = temp
        
        var i = connection.room.inPortal(data.data.x, data.data.y, data.data.z)
        if(i){
          if(typeof i === "function"){
            if(!playerFunctionQueue.includes(connection)){
              playerFunctionQueue.push(connection,i)
            }
          }else{
            var str = connection.id+":"+i
            if(!goToRoomQueue.includes(str)){
              sendThisPlayer({
                type:"message",
                data: "Going to "+i,
                username: "Server",
                fromServer:true
              })
              goToRoomQueue.push(str)
            }
          }
        }
      }else if(data.type === "message" || data.type === "die" || data.type === "harmEffect" || data.type === "achievment" ||  data.type === "playSound" || data.type === "mySkin"){
        sendPlayers(message.utf8Data)
      }else if(data.type === "setBlock" || data.type === "setTags"){
        if(!connection.room.canEdit || (data.type === "setBlock" && connection.room.inUneditable(data.data.x,data.data.y,data.data.z) || data.type === "setTags" && connection.room.inUneditable(data.x,data.y,data.z)) && !admins.includes(connection.username)) {
          if(data.type === "setBlock"){
            let temp = data.data.block
            data.data.block = data.data.prevBlock || 0
            sendThisPlayer(data)
            sendThisPlayer({
              type:"message",
              username:"Server",
              data:`§c<b>HEY!</b>§f Sorry, but you can't ${temp ? "place" : "break"} that there.`,
              fromServer:true
            })
          }
          return
        }
        if(data.type === "setBlock"){
          connection.room.world.setBlock(data.data.x,data.data.y,data.data.z,data.data.block)
        }else if(data.type === "setTags"){
          connection.room.world.setTags(data.x,data.y,data.z,data.data)
        }
        sendPlayersThisRoom(message.utf8Data)
      }else if(data.type === "entityPos"){
        if(!connection.room.canEdit) {
          return sendThisPlayer({
            type:"entityDelete",
            id:data.id
          })
        }
        
        delete data.type
        var e = connection.room.entities
        var found = false
        for(var i = 0; i<e.length; i++){
          var ent = e[i]
          if(ent.id === data.id){
            e[i] = data
            found = true
            continue
          }
        }
        if(!found){
          e.push(data)
        }

        sendPlayersThisRoom(message.utf8Data)
      }else if(data.type === "entityDelete"){
        if(!connection.room.canEdit) return
        
        var e = connection.room.entities
        for(var i = 0; i<e.length; i++){
          var ent = e[i]
          if(ent.id === data.id){
            e.splice(i,1)
            continue
          }
        }

        sendPlayers(message.utf8Data)
      }else if(data.type === "hit"){
        sendPlayer(message.utf8Data, data.TO)
      }else if(data.type === "diamondsToYou"){
        sendPlayer(JSON.stringify({
          type:"diamondsToYou"
        }), data.TO)
      }else if(data.type === "fetchUsers"){
        var arr = []
        players.forEach(u => {
          arr.push(u.username)
        })
        sendThisPlayer(JSON.stringify({
          type:"message",
          username:"Server",
          data:arr.length + " players online: " + arr.join(", "),
          fromServer:true
        }))
      }
    })
    connection.on('close', function(){
      var i = players.indexOf(connection)
      players.splice(i,1)
      if(saveActivity) Log(connection.username+" has left");else console.log(connection.username+" has left")
      if(connection.room){
        connection.room.players.splice(connection.room.players.indexOf(connection), 1)
      }
      sendPlayers(JSON.stringify({
        type:"dc",
        data: connection.id
      }))
      sendPlayers(JSON.stringify({
        type:"message",
        data: connection.username+" left. "+players.length+" players now.",
        username: "Server",
        fromServer:true
      }))
    })
  })
  function getInfo(){
    return {
      name,
      description,
      players:players.map(p => p.username),
      thumbnail
    }
  }

  function on(event, cb){
    if(event === "join") onJoin = cb
  }

  return {
    getInfo:getInfo,
    getLog:() => log,
    on:on,
    createRoom: createRoom,
    getRoom: room => rooms[room] || null,
    deleteRoom: deleteRoom,
    db:db,
    players:players
  }
}

module.exports = init